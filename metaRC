# MetaRC
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

export PS1='\t \[\e[0;3$(($RANDOM%7+1))m\]\H:/$(pwd) \j > \[\e[00m\]'

BASH_ENV=$HOME/.bashrc
HISTTIMEFORMAT=$(date +%Y%m%d-%H%M%S--)

# Toolbox .bashrc
alias psg='ps aux | grep "$1"'
alias bck='cp $1 $1.$(date +"%m%d%y").bak && cp /dev/null $1 && gzip $1.$(date +"%m%d%y").bak'
alias lsl='ls -larth --color=auto'
alias ls='ls --color=auto'
alias pscpu='ps auxf | sort -nr -k 3'
alias pscpu10='ps auxf | sort -nr -k 3 | head -10'
alias l='ls -larth'
alias lsofof='lsof | grep $1'
alias netdns='ss -atxr'
alias netip='ss -tawp'
alias netipall='ss -tawpx'
alias errors='grep -i error * | less'
alias broot='sudo su -'
alias boxstats='uptime && users && date'
alias errorhunt='grep -i error * | less'
alias dusage='df -h && date'
alias squeeze='sudo gzip *log; echo -; sudo gzip */*log; echo --; sudo gzip */*/*log; echo ---; sudo gzip */*/*/*log; echo ----; sudo gzip */*/*/*/*log; echo -----; sudo gzip */*/*/*/*log; echo ------;'
alias loghunt='ls -larth *log; echo -; ls -larth */*log; echo --; ls -larth  */*/*log; echo ---;ls -larth */*/*/*log; echo ----; ls -larth */*/*/*/*log; echo -----; ls -larth */*/*/*/*log; echo ------;'
alias scripter='cd /usr/local/scripts'
alias cfger='cd /usr/local/cfgs'
alias brutezip='sudo gzip $1/*log'
alias bkoff='bigreport && cp ~/*out /var/log ; tar czvf backup-$(hostname)-$(date +'%m%d%y%H%M%S'.tgz /var/log && scp backup*.tgz $(cat /tmp/user)@$(cat /tmp/backup):/tmp/ && shutdown -r now'
alias ff='firefox 2>> firefox.$(date +%m%d%y-%H_%S).log'
alias chrm='chromium 2>> chromium.$(date +%m%d%y-%H_%S).log'
# openssl section
alias rsa4096='openssl genrsa 4096'
alias rsa048='openssl genrsa 2048'
alias newcsr='openssl req -out CSR.csr -new -key ' # pass the key name after the alias like: newcsr mykey.key
alias checkcsr='openssl req -text -noout -verify -in' # pass the csr name like: checkcsr CSR.csr
alias checkkey='openssl rsa -check -in' # pass the key name like: checkkey mykey.key
alias checkcrt='openssl x509 -text -noout -in' # pass the cert name like: checkcrt mycert.crt

SVN_EDITOR=vim


######################################## ->  
#                                            ->          ->
#                                     -->     ->
#        collection             ->   ->    ->
#                                   ->                ->
#                                      --->  -> 
########################################          ->

ext-ip() { 
    lynx --dump $1; 
}

netest() {
    val=$(which ss)
    if [ -z $val ]; then
      ss -an | grep -v u_str | grep EST
    else
      netstat -tan | grep EST
    fi
}

extract() {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xvjf $1     ;;
            *.tar.gz)    tar xvzf $1     ;;
            *.bz2)       bunzip2 $1      ;;
            *.rar)       unrar x $1      ;;
            *.gz)        gunzip $1       ;;
            *.tar)       tar xvf $1      ;;
            *.tbz2)      tar xvjf $1     ;;
            *.tgz)       tar xvzf $1     ;;
            *.zip)       unzip $1        ;;
            *.Z)         uncompress $1   ;;
            *.7z)        7z x $1         ;;
            *)           echo "'$1' cannot be extracted via >extract<" ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}

tst() {
    month="$1"
    find . -newermt "01-$month -1 sec" -and -not -newermt "01-$month +1 month -1 sec" -exec tar -rvf $1.tar {} \;
    gzip -9 $1.tar || echo "No data from $month found."
}

dsort() {
for y in 2019 2018 2017 2016 2015 2014 2013 2012 2011 2010 2009; do
  echo "Year $y";
  for x in Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec; do
    echo "Setting Month to $x";
    passalong=$x-$y
    tst $passalong
  done
  echo "Completed year $y..."
done
}

repeat() {
    local i max
    max=$1; shift;
    for ((i=1; i <= max ; i++)); do  # --> C-like syntax
        eval "$@";
    done
}

lsnp() { 
ls -l $1 | awk '{k=0;for(i=0;i<=8;i++)k+=((substr($1,i+2,1)~/[rwx]/) *2^(8-i));if(k)printf("%0o ",k);print}'; 
}

statl() {
stat -c '%a %n' 
}

remindperms() {
echo "0    (No read, no write, no execute)     ---"
echo "1    (No read, no write, execute)    --x"
echo "2    (No read, write, no execute)    -w-"
echo "3    (No read, write, execute)    -wx"
echo "4    (Read, no write, no execute)    r--"
echo "5    (Read, no write, execute)    r-x"
echo "6    (Read, write, no execute)    rw-"
echo "7    (Read, write, execute)   rwx"
echo "(who)    u        User"
echo "(who)    g	    Group owner"
echo "(who)    o	    Other"
echo "(who)    a	    All (“world”)"
echo "(action)     +        Adding permissions"
echo "(action)     -	    Removing permissions"
echo "(action)     =	    Explicitly set permissions"
echo "(permissions)    r	    Read"
echo "(permissions)    w	    Write"
echo "(permissions)    x	    Execute"
echo "(permissions)    t	    Sticky bit"
echo "(permissions)    s	    Set UID or GID"
}

colorz() {
for fgbg in 38 48 ; do # Foreground / Background
    for color in {0..255} ; do # Colors
        # Display the color
        printf "\e[${fgbg};5;%sm  %3s  \e[0m" $color $color
        # Display 6 colors per lines
        if [ $((($color + 1) % 6)) == 4 ] ; then
            echo # New line
        fi
    done
    echo # New line
done
}

stripsp() {
tr -d '\040\011\012\015'
}
stripbl() {
tr -d '[blank]'
}
rmblank() {
sed '/^\s*$/d'
}
rmblankw() {
sed -i '/^\s*$/d'
}

scrub() {
sed 's/[:graph:]/∎//g'
}

scrubnumberswithlove() {
sed 's/[0-9]//♥/g'
}
alias snwl="scrubnumberswithlove"

scrubletterswithlove() {
sed 's/[a-Z]/♥/g'
}
alias slwl="scrubletterswithlove"

scrubnumbers() {
sed 's/[0-9]/∎/g'
}
alias scbn="scrubnumbers"

scrubletters() {
sed 's/[a-Z]/∎/g'
}
alias sblts="scrubletters"

bigreport() {
  touch ~/df.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  touch ~/lsof.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  touch  ~/netstat.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  touch ~/netstat.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  touch  ~/facter.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  touch  ~/users.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  touch  ~/last.$(hostname).$(date +'%m%d%y:%H:%M%S').out

  df -h > ~/df.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  lsof > ~/lsof.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  netstat -tan > ~/netstat.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  free -m > ~/free.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  facter > ~/facter.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  w > ~/users.$(hostname).$(date +'%m%d%y:%H:%M%S').out
  last > ~/last.$(hostname).$(date +'%m%d%y:%H:%M%S').out
}

harvest() {
  for x in $@ ; do tar czvf harvest.$(date +'%m%d%y').$(hostname).$(echo "$@" | tr -d '\040\011\012\015').tgz "$x"; done
}

#######################################################---------------------> Enjoy.

# Avoid duplicates
export HISTCONTROL=ignoredups:erasedups
# When the shell exits, append to the history file instead of overwriting it
shopt -s histappend
shopt -s extglob
shopt -s nullglob

# After each command, append to the history file and reread it
export PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND$'\n'}history -a; history -c; history -r"

#CryptoCore
# These functions are used for bitwise XOR operations
# for ad-hoc academic cryptographic batches.

# Convert common decimals to binary.
# The int2bin function can only handle 20 character inputs at a time.
int2bin() {
    num="$1"
    bin=""
    padding=""
    base2=(0 1)
    while [ "$num" -gt 0 ]; do
        bin=${base2[$(($num % 2))]}$bin
        num=$(($num / 2))
    done
    if [ $((8 - (${#bin} % 8))) -ne 8 ]; then
        printf -v padding '%*s' $((8 - (${#bin} % 8))) ''
        padding=${padding// /0}
    fi
    echo $padding$bin
}

# Call tr program to remove whitespace of all kinds
# to prepare for bitwise XOR.

# Convert binary to decimal. This thing needs work.
bin2dec() {
    echo $((2#$1))
}

# Return the seed length.
msglgth() {
SETMSGLGTH=$(cat ~/seeds/a.xor | wc -c)
}

# Bitwise XOR.
exor() {
bash ~/Scripts/xor.sh
}
# Repeat n times command.
repeat() {
    local i max
    max=$1; shift;
    for ((i=1; i <= max ; i++)); do  # --> C-like syntax
        eval "$@";
    done
}
# One-time-pad batch XOR.
otpbatch() {
for datasets in $(ls ~/seeds/*); do 
    cat $datasets | stripper > ~/seeds/b.xor; 
    exor > "$datasets".output; 
done 2> /dev/null &
}

# Same as otpbatch but with verbose output
reqbatch() {
for datasets in $(ls ~/seeds/*.xor); do
  cp $datasets ~/seeds/b.xor
  echo "now b.xor is $(cat ~/seeds/b.xor)";
  echo "XOR $datasets against a.xor - $(cat ~/seeds/a.xor)"
  echo $(exor) > "$datasets".output;
done 
}

# Run a validation check on the seed files.
libvalidate() {
for data in $(ls ~/seeds/*); do
    echo "$data"; 
    cat "$data" | wc -c; 
    echo "$data stripped"; 
    cat "$data" | stripper | wc -c; 
done
}

# Generate a medium sized library of binary digits for playing with.
libgen() { 
    for x in {1000..9999}; 
        do int2bin "$x" > "$x".xor ; 
    done
}

######### Python extra tools section below.

byteconv() {
python -c "import pprint;pprint.pprint(zip(('Byte', 'KByte', 'MByte', 'GByte', 'TByte'), (1 << 10*i for i in xrange(5))))"
}
sv2json() {
python -c "import csv,json;print json.dumps(list(csv.reader(open('csv_file.csv'))))"
}
dhex() {
export HEXIN=$1 ; python -c "print ''.join(chr(int(''.join(i), 16)) for i in zip(*[iter('$HEXIN')]*2))"; 
}
